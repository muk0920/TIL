### 데이터베이스 정규화 



- 데이터베이스의 설계를 재구성하는 테크닉이다. 
- 정규화를 통해 불필요한 데이터를 없앨 수 있고, 삽입/갱신/삭제 시 발생할 수 있는 각종 이상현상들을 방지할 수 있다. 



- 데이터베이스의 정규화 목적은 주로 2가지 
  - 불필요한 데이터를 제거한다 
  - 데이터 저장을 논리적으로 한다. ( 구성이 논리적이고 직관적이어야한다. )



### 정규화의 법칙 

- 1차 정규화 - 2차 정규화 - 3차 정규화 - BCNF - 4차 정규화 - 5차 정규화 

( 실무에서는 4차 정규화 이상은 잘 하지 않는다. )



#### 1차 정규화 

- 각 로우마다 컬럼의 값이 1개씩만 있어야 한다. 이를 컬럼이 원자값을 갖는다고 한다.

  

예를 들어, 아래와 같은 경우 Adam의 Subject가 Biology와 Maths 두 개 이기 때문에 1차 정규형을 만족하지 못합니다.

![img](images/9983DA3359E7855B34)



위의 정보를 표현하고 싶은 경우 이렇게 한 개의 로우를 더 만들게 됩니다. 결과적으로 1차 정규화를 함으로써 데이터 redundancy는 더 증가하였습니다. 데이터의 논리적 구성을 위해 이 부분을 희생하는 것으로 볼 수 있습니다.

![img](images/9967D83359E7861E07)



#### 2차 정규화

- 테이블의 모든 컬럼이 완전 함수적 종속을 만족하는 것이다. 
- 기본 키 중에 특정 컬럼에만 종속된 컬럼(부분적 종속)이 없어야한다. 



위 테이블의 경우 기본키는 (Student, Subject) 두 개로 볼 수 있습니다. 이 두 개가 합쳐져야 한 로우를 구분할 수가 있습니다. 근데 Age의 경우 이 기본키중에 Student에만 종속되어 있습니다. 즉, Student 컬럼의 값을 알면 Age의 값을 알 수 있습니다. 따라서 Age가 두 번 들어가는 것은 불필요한 것으로 볼 수 있습니다.

**Student Table**

![img](images/99589D3359E789FA30)

**Subject Table**

![img](images/99C5183359E789FB14)



이를 해결하기 위한 방법은 위처럼 테이블을 쪼개는 것입니다. 그러면 두 테이블 모두 2차 정규형을 만족하게 됩니다. 위 테이블의 경우 삽입/갱신/삭제 이상을 겪지 않게됩니다. 하지만 조금 더 복잡한 테이블의 경우, 갱신 이상을 겪기도하는데 이를 해결하는 것이 바로 3차 정규화입니다.



.. 미완성

